---
title: 'Enhancing Document Signing: Introducing 5 New Advanced Fields'
description: 'Explore Documenso's new advanced signing fields, including improved text fields, numbers, radio buttons, checkboxes, and dropdowns. Learn about the development challenges we overcame and how these additions provide greater flexibility for document signing.'
authorName: 'Catalin Pit'
authorImage: '/blog/blog-author-catalin.webp'
authorRole: 'I like to code and write'
date: 2024-08-09
tags:
  - Signing fields
  - Development
---

Until recently, Documenso provided a set of 5 fields for document signing: signature, email, name, date, and a text field for additional information. While these fields covered the basic requirements for document signing, we recognized the need for more flexibility and variety.

As a result, we've decided to introduce several additional fields, such as:

- _(an improved)_ Text field
- Number field
- Radio field
- Checkbox field
- Dropdown/Select field

The introduction of these new fields brings more flexibility and variety to Documenso. They enable document owners to gather more specific or extra information from the signers.

## New Fields Introduction

Let's start by looking at the new fields introduced.

### Text Field

While the text field was available previously, it lacked the ability to configure it. It was a simple input box where signers could enter a single line of text.

The image illustrates the old text field in the document editor.

![Old text signing field in the Documenso document editor](/blog/advanced-fields/old-text-field.webp)

The revamped text field now offers a range of configuration options, allowing document owners to:

- Add a label, placeholder, default text, and character limit
- Set the field as required or read-only

![The advanced settings tab for the text field in the Documenso document editor](/blog/advanced-fields/text-field-advanced-settings.webp)

On the signing side, the field remained mostly the same visually. The only thing that changed is the functionality, which needs to consider the validation rules. For example, if the field is required, the user must enter a value to sign it. Or, if the field has a character limit, the value entered by the user shouldn't exceed the limit.

The image below illustrates four different text fields with various configurations.

![The text signing field on the Documenso signing page](/blog/advanced-fields/text-field-signing.webp)

The first text field has no configuration. The signer can sign the field by entering any text.

![The first text field input](/blog/advanced-fields/text-field-signing.webp)

The second text field has the following configurations:

- Label
- Placeholder
- Default text
- Character limit

Since there is a default value, the field auto-signs with that value. However, the user can re-sign the field with a new value that doesn't exceed the character limit.

![The second text field input](/blog/advanced-fields/second-text-field-input.webp)

The third field has the same configurations as the second one, with one addition - the `required` option is checked. Apart from that, it works like the second field.

![The third text field input](/blog/advanced-fields/third-text-field.input.webp)

The fourth field has the same configurations as the second one, with one addition—`read-only` is checked. As a result, the field auto-signs with the default value, and the signer cannot modify it.

### Number Field

We also introduced a new "Number" field for inserting and signing documents with numeric values. This field helps collect quantities, measurements, and other data best represented as numbers.

![The advanced settings tab for the number field on the Documenso document editor page](/blog/advanced-fields/number-field-advanced-settings.webp)

The "Number" field offers a range of configuration options, allowing document owners to:

- Set a label, placeholder and default value
- Specify the number format
- Mark the field as _required_ or _read-only_
- Specify minimum and maximum values

### Radio Field

Radio buttons allow signers to select a single option from a pre-defined list the document owner sets.

Before sending the document for signing, the document owner must add at least one radio option, which can contain a string or an empty value and can be checked or unchecked. However, it's important to note that only one option can be checked at a time.

When it comes to field configuration, the document owner can mark the field as _required_ or _read-only_.

![The advanced settings tab for the radio field in the Documenso document editor](/blog/advanced-settings/radio-field-advanced-settings.webp)

The image below shows what the signer sees after the document is sent for signing.

![The radio signing field on the Documenso signing page](/blog/advanced-settings/radio-field-sign-page.webp)

It's important to mention that the image is slightly modified so you can see both states of the field—signed and unsigned. Since the field has a checked value (option 2 - `radio-val-2-checked`), it will automatically sign with that value and appear like the field marked with the number 1.

If the field is not marked as read-only, the signer can un-sign it and choose another option by clicking on it. Alternatively, the signer can re-sign with the default value by refreshing the page.

### Dropdown/Select Field

We have also introduced a new "Dropdown/Select" field that allows signers to pick an option from a pre-defined list of choices. This field type is useful for scenarios such as selecting a country, state, or category where a limited number of valid options exist.

When configuring the "Dropdown/Select" field, the document owners can:

- Add multiple options
- Mark the field as _required_ or _read-only_
- Pick a default option from the list of choices

![The advanced settings tab for the select field in the Documenso document editor](/blog/advanced-settings/select-field-advanced-settings.webp)

The image below illustrates the field on the signing page.

![The select field on the Documenso document signing page](/blog/advanced-fields/select-field-sign-page.webp)

If the document owner does not set a default value, the "Dropdown/Select" field will not auto-sign. The signer must click on the field and select an option from the dropdown list to sign it. After signing, the field will display the selected value, similar to a signed text field.

When the field is marked as required, signers must select a value before completing the signing process. However, if the document owner marks the field as read-only, signers can view the selected value but cannot modify it.

### Checkbox Field

The last field introduced is the "Checkbox" field, which allows signers to select multiple options from a pre-defined list. Such a field is helpful for scenarios where signers need to choose multiple items or agree to several terms and conditions, for example.

Before sending the document for signing, the document owner must add at least one checkbox option. This option can contain a string or an empty value and can be checked or unchecked. Unlike the "Radio" field, the "Checkbox" field can have multiple checked options.

Like other fields, the document owner can mark the "Checkbox" as _required_ or _read-only_. In addition to that, it also has a validation field. The document owner can specify how many checkboxes the signer should sign:

- Select at least X _(a number from 1 to 10)_
- Select at most X _(a number from 1 to 10)_
- Select exactly X _(a number from 1 to 10)_

![The advanced settings tab for the checkbox field in the Documenso document editor](/blog/advanced-fields/checkbox-field-advanced-settings.webp)

The image below shows what the signer sees after the document is sent for signing.

![The checkbox field on the Documenso document signing page](/blog/advanced-fields/checkbox-sign-page.webp)

The image illustrates both field states - signed and un-signed.

In this example, the 'Checkbox' field has two options checked by default, so it auto-signs. The field marked '1' appears when the signer visits the page for the first time or when the user refreshes the page and no option is selected. The field marked '2' displays the cleared state, where all choices have been deselected. This shows how the field looks when a user clears all selections.

In this example, no validation rule has been set, allowing the signer to select any options. However, if a validation rule were applied, the signer's choices would need to meet the validation criteria.

## Development Challenges

The introduction of these new fields wasn't without its challenges. The main challenges included storing the new information for the fields, visual differentiation of recipients using colours, and implementing checkbox and radio fields.

### 1st Challenge: Store New Field Information

One of the first challenges we encountered was deciding on the best approach to store the additional information for each new field in the database. The fact that each field has unique properties, with only the `required` and `read-only` properties being shared by all fields, made the task trickier.

Our database has a `Field` model that represents the field and its various properties:

```js
model Field {
 id          Int        @id @default(autoincrement())
 secondaryId String     @unique @default(cuid())
 documentId  Int?
 templateId  Int?
 recipientId Int
 type        FieldType
 page        Int
 positionX   Decimal    @default(0)
 positionY   Decimal    @default(0)
 width       Decimal    @default(-1)
 height      Decimal    @default(-1)
 customText  String
 inserted    Boolean
 Document    Document? @relation(fields: [documentId], references: [id], onDelete: Cascade)
 Template    Template? @relation(fields: [templateId], references: [id], onDelete: Cascade)
 Recipient   Recipient  @relation(fields: [recipientId], references: [id], onDelete: Cascade)
 Signature   Signature?

 @@index([documentId])
 @@index([templateId])
 @@index([recipientId])
}
```

Initially, we considered creating a new model called `FieldMeta` to store the information for the new advanced fields, with each property represented as a separate column in the model. However, this approach has 2 issues.

First, the advanced fields only share two common properties: `required` and `read-only`. Other than these, the fields have unique properties, which would result in many nullable columns in the `FieldMeta` model.

Secondly, creating a new database table with columns for each field property and the associated relationships would increase the database complexity.

As a result, we decided to look for another solution that would better work with our use case.

### Solution: JSONB Field

Since the advanced settings data is unique to each field, we decided to store it in the JSON format. PostgreSQL has a specialized data type called `JSONB` for efficiently storing JSON values. As a result, we introduced a new optional property named `fieldMeta` of type `JSONB` in the `Field` model.

```js
model Field {
 id          Int        @id @default(autoincrement())
 secondaryId String     @unique @default(cuid())
 documentId  Int?
 templateId  Int?
 recipientId Int
 type        FieldType
 page        Int
 positionX   Decimal    @default(0)
 positionY   Decimal    @default(0)
 width       Decimal    @default(-1)
 height      Decimal    @default(-1)
 customText  String
 inserted    Boolean
 Document    Document?  @relation(fields: [documentId], references: [id], onDelete: Cascade)
 Template    Template? @relation(fields: [templateId], references: [id], onDelete: Cascade)
 Recipient   Recipient  @relation(fields: [recipientId], references: [id], onDelete: Cascade)
 Signature   Signature?
 fieldMeta   Json? <<<<<----- added this

 @@index([documentId])
 @@index([templateId])
 @@index([recipientId])
}
```

This field can store any JSON object, allowing us to store each field's different settings. However, this introduces a potential issue—we lose the benefit of type checks that come with using specific database field types.

To ensure the integrity of the data, we use Zod schemas to parse and validate the field metadata. When we retrieve the data from the database, we parse it with Zod to ensure that it matches the expected format. We also use Zod to parse the data before saving it to the database, which helps us avoid inserting invalid data.

This approach has several benefits:

- **Consistency**: The application uses the same Zod schema to retrieve and insert data into the database. That means the data is consistent throughout the app.
- **Type safety**: By parsing the data with Zod, we can guarantee that the data matches the expected types and structure. We can also use Zod's `infer` utility to enable strong typing and autocompletion.
- **Better error handling**: Zod provides thorough error messages indicating which part of the data is invalid. That makes it easier & faster to debug and fix issues.
- **Maintainability**: Re-using the same Zod schema for retrieving and inserting data into the database makes it easier to maintain the data structure.

It's important to note that the `JSONB` type also comes with drawbacks, such as data querying. Since the data is stored as JSON (more specifically, in binary format), complex queries can be less efficient compared to querying normalized relational data. On top of that, querying data requires specific operators and functions, such as `->`, `->>`, `@>`, and `?`. This makes the querying more verbose and less intuitive, and hence, it requires more finesse.

Another drawback is the storage overhead. `JSONB` data is stored in a binary format, which can result in some storage overhead compared to normalized relational data. In cases where the JSON data is large or contains a lot of redundant information, the storage overhead can be significant.

Considering all that, `JSONB` makes sense for our use case because the field meta information is relatively small and doesn't require complex querying. The flexibility of the `JSONB` type suits the dynamic nature of the `fieldMeta` field.

> Postgres provides 2 fields for storing JSON data—`json` and `jsonb`—the latter being more performant. For more information, you can [check out the documentation](https://www.postgresql.org/docs/current/datatype-json.html).

### 2nd Challenge: Storing Fields' Advanced Settings on Frontend

The next challenge was determining the optimal solution for storing the advanced field settings entered by the users.

Currently, the app saves the fields and associated settings to the database when the user advances to the next step.

![Documenso advanced field signing](/blog/advanced-fields/documenso-advanced-fields-signing.webp)

The fields are saved locally until the user proceeds to the next step. That means all the fields and their associated settings are lost when the user closes the advanced settings tab, refreshes the page, closes the tab, or navigates to the previous step.

In the future, we plan to improve this flow and save the fields on blur. This way, the user's data is preserved even if they navigate away from the page. But until then, we had to think of a solution to save the advanced settings after the user closes the settings tab.

### Solution: Local Storage

The solution in this case is to use the local storage for the temporary storage of the advanced settings. The reason for this approach is because the fields are available only locally. If the fields were saved in the database, we could save the advanced settings along with them.

![Documenso field advanced settings](/blog/advanced-fields/documenso-field-advanced-settings.webp)

Since the fields are not stored in the database, we need to persist the data until the user proceeds to the next step, at which point the data gets saved to the database. Saving the data in the local storage allows users to open, close, and configure various fields in the advanced settings tab without losing any data.

When the user proceeds to the next step, the fields and their advanced settings are saved into the database, and the local storage is cleared.

We also recognized the dangers of saving data to local storage, as users could potentially modify it and break the application. As a result, we have implemented extensive checks on both the backend and frontend, in addition to parsing and validating data with Zod.

However, this solution has limitations. The data is still lost when the user refreshes the page, navigates to the previous step, or closes the browser, as the fields are wiped out from the document. A future improvement to save the fields to the database on blur will help eliminate this issue.

### 3rd Challenge: Radio and Checkbox Fields

The Radio and Checkbox field implementations were challenging from both logical and design standpoints. That is mainly because they can contain both empty and non-empty values. Moreover, the Checkbox field allows the user to select multiple values.

![The radio and checkbox signing fields on the Documenso document signing page](/blog/advanced-fields/radio-and-checkbox-fields.webp)

The image above shows the Radio and Checkbox fields in the document editor. The Radio field on the left-hand side has 4 options, 1 of which is checked. The Checkbox field on the right-hand side has 4 options, 2 of which are checked.

Between the 2, the Radio field was easier to implement because the user can only select one option, which means it has simpler workings. The signer clicks on the option they want to select, and the field auto-signs with that value. If the user wants to change the selection, they can click on another option to un-sign the field and sign it with the new value.

However, the Checkbox field was more challenging because users can select multiple options simultaneously. This means the field can contain multiple values, which makes it more complex to implement. On top of that, the Checkbox field can have validation rules, such as selecting at least X, at most X, or exactly X options. Lastly, the user can check and uncheck the options by clicking on them or clear the field by clicking on the clear button. There are a lot of moving parts that need to be handled correctly.

### Solution

In contrast to the other challenges, I'm going to discuss the general implementation rather than a specific solution. We'll focus on the particularities and the most challenging parts of the implementation rather than going over the entire implementation. I'll include a link to the complete implementation for each field so you can check it out if you're interested.

**Radio Field**

The way signing works for the Radio field is to pull the data from the database and display the available options. If the field has a default value set by the document sender, it auto-signs with that value.

```ts
...
  const values = parsedFieldMeta.values?.map((item) => ({
    ...item,
 value: item.value.length > 0 ? item.value : `empty-value-${item.id}`,
 }));
...
  const shouldAutoSignField =
 (!field.inserted && selectedOption) ||
 (!field.inserted && defaultValue) ||
 (!field.inserted && parsedFieldMeta.readOnly && defaultValue);
...

  useEffect(() => {
    if (shouldAutoSignField) {
      void executeActionAuthProcedure({
        onReauthFormSubmit: async (authOptions) => await onSign(authOptions),
 actionTarget: field.type,
 });
 }
 }, [selectedOption, field]);
```

> You can see the complete implementation of the radio field in the [radio-field.tsx](<https://github.com/documenso/documenso/blob/main/apps/web/src/app/(signing)/sign/%5Btoken%5D/radio-field.tsx>) file.

If the field is not read-only and the user clicks on another option, the field un-signs and re-signs with the new value. If the field is read-only, the user can't change the value and hence modify the field.

Whenever the field is signed, whether by auto-signing or by the user, the value is saved in the database. Similarly, when the field is unsigned, the value is removed from the database.

Also, since the Radio field can contain empty values, we map over the values and replace the empty ones with a unique string `empty-value-${item.id}`. This is because the empty string is not a valid value for the field, and we need to differentiate between empty and non-empty values.

**Checkbox Field**

The Checkbox field implementation is similar to the Radio field, with the main difference being that the Checkbox field can contain multiple values. Moreover, it also has validation rules that need to be enforced. Some examples of validation rules are selecting at least X, at most X, or exactly X options. Therefore, we must keep track of the user choices and validate them against the validation rules.

```ts
...
  const values = parsedFieldMeta.values?.map((item) => ({
    ...item,
 value: item.value.length > 0 ? item.value : `empty-value-${item.id}`,
 }));

  const [checkedValues, setCheckedValues] = useState(
    values
      ?.map((item) =>
        item.checked ? (item.value.length > 0 ? item.value : `empty-value-${item.id}`) : '',
 )
 .filter(Boolean) || [],
 );
...
```

Similarly to the Radio field, we map over the values and replace the empty ones with a unique string `empty-value-${item.id}`. This is because the empty string is not a valid value for the field, and we need to differentiate between empty and non-empty values.

We also keep track of the checked values in the state, which allows us to display the field correctly and validate values against the validation rules.

```ts
...
  const values = parsedFieldMeta.values?.map((item) => ({
    ...item,
 value: item.value.length > 0 ? item.value : `empty-value-${item.id}`,
 }));

  const [checkedValues, setCheckedValues] = useState(
    values
      ?.map((item) =>
        item.checked ? (item.value.length > 0 ? item.value : `empty-value-${item.id}`) : '',
 )
 .filter(Boolean) || [],
 );

  const checkboxValidationRule = parsedFieldMeta.validationRule;
  const checkboxValidationLength = parsedFieldMeta.validationLength;
  const validationSign = checkboxValidationSigns.find(
 (sign) => sign.label === checkboxValidationRule,
 );
...
```

Then, we retrieve the validation rule and length from the database and find the corresponding validation sign (e.g., ">=", "=", "<=") based on the rule label. The `checkboxValidationSigns` array contains the objects that map the rule labels to the signs.

```ts
export const checkboxValidationSigns = [
  {
    label: 'Select at least',
    value: '>=',
  },
  {
    label: 'Select exactly',
    value: '=',
  },
  {
    label: 'Select at most',
    value: '<=',
  },
];
```

Next, we check whether the length condition is met based on the validation rule, sign, and length. If it is, the user can proceed with signing the field. Otherwise, the user needs to select the correct number of options to meet the validation rule.

```ts
...
  const values = parsedFieldMeta.values?.map((item) => ({
    ...item,
 value: item.value.length > 0 ? item.value : `empty-value-${item.id}`,
 }));

  const [checkedValues, setCheckedValues] = useState(
    values
      ?.map((item) =>
        item.checked ? (item.value.length > 0 ? item.value : `empty-value-${item.id}`) : '',
 )
 .filter(Boolean) || [],
 );

  const checkboxValidationRule = parsedFieldMeta.validationRule;
  const checkboxValidationLength = parsedFieldMeta.validationLength;
  const validationSign = checkboxValidationSigns.find(
 (sign) => sign.label === checkboxValidationRule,
 );

  const isLengthConditionMet = useMemo(() => {
    if (!validationSign) return true;
    return (
 (validationSign.value === '>=' && checkedValues.length >= (checkboxValidationLength || 0)) ||
 (validationSign.value === '=' && checkedValues.length === (checkboxValidationLength || 0)) ||
 (validationSign.value === '<=' && checkedValues.length <= (checkboxValidationLength || 0))
 );
 }, [checkedValues, validationSign, checkboxValidationLength]);
...
```

The implementation is more complex, but here, we look at the most challenging parts of it. The user can select multiple options; the field auto-signs with the selected values. The user can also un-sign the field by unchecking the options. The validation rules are enforced, and the user needs to select the correct number of options to sign the field.

> You can see the complete implementation of the checkbox field in the [checkbox-field.tsx](<https://github.com/documenso/documenso/blob/main/apps/web/src/app/(signing)/sign/%5Btoken%5D/checkbox-field.tsx>) file.

### 4th Challenge: Recipients' Colors

Another challenge we faced was using colours to differentiate recipients. The issue was that we needed to dynamically generate and re-use the same Tailwind classes across several components. However, TailwindCSS only generates the CSS classes used in the project and discards the unused ones from the final build. This resulted in the colours not being applied to the components, as the classes were not used in the code.

The images below illustrate the recipients' colours in 2 different states.

In the first image, the "Signature" field on the right-hand side is in the active state, indicated by the orange colour. The active state is triggered when the user clicks on the field to drag it onto the document. On the left-hand side of the same image, the signature field placed on the document is shown in the normal state (not active).

![Screenshot illustrating the fields for a signer on the Documenso document editor page](/blog/advanced-fields/recipient-colours.webp)

On the other hand, the second image shows the "Signature" field on the right-hand side in the normal state (not clicked, not active). The signature field placed on the document, shown on the left-hand side, is in the active state.

![Screenshot illustrating the active state for a field on the Documenso document editor page](/blog/advanced-fields/field-active-state)

The document editor consists of various components, including those representing the fields, recipients, and other elements. That means the same colours and code are re-used across multiple components.

```ts
export const combinedStyles = {
  'orange-500': {
 ringColor: 'ring-orange-500/30 ring-offset-orange-500',
 borderWithHover: 'border-orange-500 hover:border-orange-500',
    ...,
 },
  'green-500': {
 ringColor: 'ring-green-500/30 ring-offset-green-500',
 borderWithHover: 'border-green-500 hover:border-green-500',
    ...,
 },
  'blue-500': {
 ringColor: 'ring-blue-500/30 ring-offset-blue-500',
 borderWithHover: 'border-blue-500 hover:border-blue-500',
    ...,
  'gray-500': {
 ringColor: 'ring-gray-500/30 ring-offset-gray-500',
 borderWithHover: 'border-gray-500 hover:border-gray-500',
    ...,
 },
  ...,
};

export const MyComponent = () => {
  const selectedSignerStyles = useSelectedSignerStyles(selectedSigner, combinedStyles);

  return (
    <div
      className={cn(
 selectedSigner ? selectedSignerStyles.ringClass : selectedSignerStyles.borderClass,
 )}
    >
      <h1>Hello</h1>
    </div>
 );
};
```

The code snippet above shows the naive solution to re-using the colours across multiple components. The `combinedStyles` object contains various properties for the different parts of the components, such as the ring colour, border colour, and hover colour, to name a few. All these object properties contain the TailwindCSS classes for the respective colours.

Then, the components would use custom hooks to apply the appropriate styles based on the selected recipient. For example, if recipient 1 is selected, the component would use the `green-500` styles from the `combinedStyles` object. All the elements related to recipient 1, such as the dropdown menu and the fields, would have a green colour.

![Screenshot illustrating the recipient colour on the Documenso document editor page](/blog/advanced-fields/recipient-colour-example)

The problem with this approach is that we can't import the `combinedStyles` object into other components because TailwindCSS will remove the unused classes. That means we had to copy and paste the same object into multiple files. As a result, it pollutes the codebase with duplicated code, which makes it harder to maintain and scale the code. As the application grows, the `combinedStyles` object will become larger and more complex. Moreover, it's not very flexible, as it doesn't allow for easy customization of the colours.

While this approach works as intended, more efficient and scalable solutions exist. To overcome this challenge, we decided to pick a different approach.

### Solution: Modularise the Logic

We moved the colours and associated hooks to a separate file to address the challenge of re-using colours across multiple components. The styles would only be defined in this file and accessed from the components through custom hooks.

```ts
export const SIGNER_COLOR_STYLES = {
 green: {
 default: {
 background: 'bg-[hsl(var(--signer-green))]',
 base: 'rounded-lg shadow-[0_0_0_5px_hsl(var(--signer-green)/10%),0_0_0_2px_hsl(var(--signer-green)/60%),0_0_0_0.5px_hsl(var(--signer-green))]',
 fieldItem:
        'group/field-item p-2 border-none ring-none hover:bg-gradient-to-r hover:from-[hsl(var(--signer-green))]/10 hover:to-[hsl(var(--signer-green))]/10',
 fieldItemInitials:
        'opacity-0 transition duration-200 group-hover/field-item:opacity-100 group-hover/field-item:bg-[hsl(var(--signer-green))]',
 comboxBoxItem: 'hover:bg-[hsl(var(--signer-green)/15%)] active:bg-[hsl(var(--signer-green)/15%)]',
 },
 },

  ...
};

export type CombinedStylesKey = keyof typeof SIGNER_COLOR_STYLES;

export const AVAILABLE_SIGNER_COLORS = [
  'green',
  'blue',
  'purple',
  'orange',
  'yellow',
  'pink',
] as const satisfies CombinedStylesKey[];

export const useSignerColors = (index: number) => {
  const key = AVAILABLE_SIGNER_COLORS[index % AVAILABLE_SIGNER_COLORS.length];

  return SIGNER_COLOR_STYLES[key];
};

export const getSignerColorStyles = (index: number) => {
  return useSignerColors(index);
};
```

> The file was truncated for readability. You can see the complete code in the [signer-colors.ts](https://github.com/documenso/documenso/blob/main/packages/ui/lib/signer-colors.ts) file from the Documenso repository.

The `SIGNER_COLOR_STYLES` object contains the styles for each colour, such as the background, border, and hover colours. Based on the signer's index, the `useSignerColors` hook gets the styles for a specific colour. The `getSignerColorStyles` function is a helper function that returns the styles for a particular signer.

Now, the components can access the colours and styles using custom hooks. For example, to get the styles for a specific signer, the component can call the `useSignerColors` hook with the signer's index.

```ts
const signerStyles = useSignerColors(recipientIndex);
```

The hook will return the styles for that signer, which can then be applied to the component. For example, you can access the signer's background colour by using `signerStyles.default.background`.

This approach makes managing the colours and styles easier, as they are defined in a single file. We can do so in a single place if we need to change or add new colours. This approach also makes the code more modular and reusable, as the styles are decoupled from the components.

However, this will later be replaced with a more efficient solution that uses CSS variables to define the colours.

## The End

We're happy to see the new advanced fields released because they offer our users more flexibility, variety, and customization options. Implementing the new fields came with its challenges, but we were able to overcome them and learn from them. We're excited to continue enhancing Documenso and providing our users with the best document signing experience.
